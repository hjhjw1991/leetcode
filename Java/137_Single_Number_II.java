public class Solution {
    public int singleNumber(int[] nums) {
        if(nums==null||nums.length==0)return 0;
        // 除了一个数以外，其他的数都出现了三次。我们假设这个数出现了一次。
        // 那么我们理想状态下如果存在O(n)的解，就只需要扫描常数次数组
        // 一种方式是暴力法，扫描一次记录出现次数，扫描第二次找到出现为1的，复杂度最多O(2n)
        // 更聪明的方法是利用数学特性
        // 逐个扫描的时候，难点在于如何判断当前的数字是出现的第一次还是第三次，因为如果出现两次那么我们通过异或操作就可以抹去这个数字了
        // 借用136题的思路的话，就需要判断当前数字是出现的第一次还是第三次
        // 每个数字有三个可能的状态，我们可以用两个变量来表示
        // 01 一次 10 两次 11 三次，而11的时候又希望能直接抹掉，所以11也可以是00
        // 那么可以这样说，当第一次出现，则放在右边，第二次出现则放在左边并且右边消掉，第三次出现则左边也消掉。这样子左边就保留了第一次出现的数
        // 下面用ab来表示这两位，并且a为第一次和第三次出现
        int a=0,b=0;
        for(int i=0;i<nums.length;i++){
            a=(a^nums[i])&(~b);
            b=(b^nums[i])&(~a);
        }
        return a;
    }
}